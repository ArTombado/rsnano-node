# This is an example configuration file for Nano. Visit https://docs.nano.org/running-a-node/configuration/ for more information.
#
# Fields may need to be defined in the context of a [category] above them.
# The desired configuration changes should be placed in config-node.toml in the node data path.
# To change a value from its default, uncomment (erasing #) the corresponding field.
# It is not recommended to uncomment every field, as the default value for important fields may change in the future. Only change what you need.
# Additional information for notable configuration options is available in https://docs.nano.org/running-a-node/configuration/#notable-configuration-options

[node]

	# Enable or disable local host peering.
	# type:bool
	# allow_local_peers = true

	# Number of threads dedicated to background node work, including handling of RPC requests. Defaults to all available CPU threads.
	# type:uint64
	# background_threads = 8

	# Number of accounts per second to process when doing backlog population scan. Increasing this value will help unconfirmed frontiers get into election prioritization queue faster, however it will also increase resource usage. 
	# type:uint
	# backlog_scan_batch_size = 10000

	# Backlog scan divides the scan into smaller batches, number of which is controlled by this value. Higher frequency helps to utilize resources more uniformly, however it also introduces more overhead. The resulting number of accounts per single batch is `backlog_scan_batch_size / backlog_scan_frequency` 
	# type:uint
	# backlog_scan_frequency = 10

	# Backup the ledger database before performing upgrades.
	# Warning: uses more disk storage and increases startup time when upgrading.
	# type:bool
	# backup_before_upgrade = false

	# Outbound traffic limit in bytes/sec after which messages will be dropped.
	# Note: changing to unlimited bandwidth (0) is not recommended for limited connections.
	# type:uint64
	# bandwidth_limit = 10485760

	# Burst ratio for outbound traffic shaping.
	# type:double
	# bandwidth_limit_burst_ratio = 3.0000000000000000

	# The maximum time the block processor can continuously process blocks for.
	# type:milliseconds
	# block_processor_batch_max_time = 500

	# Burst ratio for outbound bootstrap traffic.
	# type:double
	# bootstrap_bandwidth_burst_ratio = 1.0000000000000000

	# Outbound bootstrap traffic limit in bytes/sec after which messages will be dropped.
	# Note: changing to unlimited bandwidth (0) is not recommended for limited connections.
	# type:uint64
	# bootstrap_bandwidth_limit = 5242880

	# Number of outbound bootstrap connections. Must be a power of 2. Defaults to 4.
	# Warning: a larger amount of connections may use substantially more system memory.
	# type:uint64
	# bootstrap_connections = 4

	# Maximum number of inbound bootstrap connections. Defaults to 64.
	# Warning: a larger amount of connections may use additional system memory.
	# type:uint64
	# bootstrap_connections_max = 64

	# Change bootstrap threshold (online stake / 256 * bootstrap_fraction_numerator).
	# type:uint32
	# bootstrap_fraction_numerator = 1

	# Number frontiers per bootstrap frontier request. Defaults to 1048576.
	# type:uint32,[1024..4294967295]
	# bootstrap_frontier_request_count = 1048576

	# Number of threads dedicated to concurrent bootstrap attempts. Defaults to 1.
	# Warning: a larger amount of attempts may use additional system memory and disk IO.
	# type:uint64
	# bootstrap_initiator_threads = 1

	# Number of threads dedicated to serving bootstrap data to other peers. Defaults to half the number of CPU threads, and at least 2.
	# type:uint64
	# bootstrap_serving_threads = 1

	# Maximum time the confirming set will hold the database write transaction.
	# type:milliseconds
	# confirming_set_batch_time = 250

	# Enable or disable voting. Enabling this option requires additional system resources, namely increased CPU, bandwidth and disk usage.
	# type:bool
	# enable_voting = false

	# The external address of this node (NAT). If not set, the node will request this information via UPnP.
	# type:string,ip
	# external_address = "::"

	# The external port number of this node (NAT). Only used if external_address is set.
	# type:uint16
	# external_port = 0

	# Mode controlling frontier confirmation rate.
	# type:string,{auto,always,disabled}
	# frontiers_confirmation = "auto"

	# Number of threads dedicated to I/O operations. Defaults to the number of CPU threads, and at least 4.
	# type:uint64
	# io_threads = 8

	# Limit for number of queued confirmation requests for one channel, after which new requests are dropped until the queue drops below this value.
	# type:uint32
	# max_queued_requests = 512

	# Maximum allowed difficulty multiplier for work generation.
	# type:double,[1..]
	# max_work_generate_multiplier = 64.000000000000000

	# Number of threads dedicated to processing network messages. Defaults to the number of CPU threads, and at least 4.
	# type:uint64
	# network_threads = 8

	# When calculating online weight, the node is forced to assume at least this much voting weight is online, thus setting a floor for voting weight to confirm transactions at online_weight_minimum * "quorum delta".
	# type:string,amount,raw
	# online_weight_minimum = "60000000000000000000000000000000000000"

	# Password fanout factor.
	# type:uint64
	# password_fanout = 1024

	# Node peering port.
	# type:uint16
	# peering_port = 54000

	# Time to sleep between batch work generation attempts. Reduces max CPU usage at the expense of a longer generation time.
	# type:nanoseconds
	# pow_sleep_interval = 0

	# A list of "address" (hostname or ipv6 notation ip address) entries to identify preconfigured peers.
	# The contents of the NANO_DEFAULT_PEER environment variable are added to preconfigured_peers.
	# preconfigured_peers = ["peering-beta.nano.org"]

	# A list of representative account addresses used when creating new accounts in internal wallets.
	# preconfigured_representatives = ["nano_1defau1t9off1ine9rep99999999999999999999999999999999wgmuzxxy"]

	# Minimum receive amount. Only affects node wallets. A large amount is recommended to avoid automatic work generation for tiny transactions.
	# type:string,amount,raw
	# receive_minimum = "1000000000000000000000000"

	# Rep crawler minimum weight, if this is less than minimum principal weight then this is taken as the minimum weight a rep must have to be tracked. If you want to track all reps set this to 0. If you do not want this to influence anything then set it to max value. This is only useful for debugging or for people who really know what they are doing.
	# type:string,amount,raw
	# rep_crawler_weight_minimum = "340282366920938463463374607431768211455"

	# Minimum vote weight that a representative must have for its vote to be counted.
	# All representatives above this weight will be kept in memory!
	# type:string,amount,raw
	# representative_vote_weight_minimum = "10000000000000000000000000000000"

	# Number of threads to dedicate to request aggregator. Defaults to using all cpu threads, up to a maximum of 4
	# request_aggregator_threads = 8

	# Number of additional threads dedicated to signature verification. Defaults to number of CPU threads / 2.
	# type:uint64
	# signature_checker_threads = 4

	# Maximum number of incoming TCP connections.
	# type:uint64
	# tcp_incoming_connections_max = 2048

	# Timeout for TCP connect-, read- and write operations.
	# Warning: a low value (e.g., below 5 seconds) may result in TCP connections failing.
	# type:seconds
	# tcp_io_timeout = 15

	# Number of seconds before deleting an unchecked entry.
	# Warning: lower values (e.g., 3600 seconds, or 1 hour) may result in unsuccessful bootstraps, especially a bootstrap from scratch.
	# type:seconds
	# unchecked_cutoff_time = 14400

	# If true, allocate memory from memory pools. Enabling this may improve performance. Memory is never released to the OS.
	# type:bool
	# use_memory_pools = true

	# Delay before votes are sent to allow for efficient bundling of hashes in votes.
	# type:milliseconds
	# vote_generator_delay = 100

	# Number of bundled hashes required for an additional generator delay.
	# type:uint64,[1..11]
	# vote_generator_threshold = 3

	# Local representatives do not vote if the delegated weight is under this threshold. Saves on system resources.
	# type:string,amount,raw
	# vote_minimum = "1000000000000000000000000000000000"

	# A list of "address:port" entries to identify work peers.
	# work_peers = []

	# Number of threads dedicated to CPU generated work. Defaults to all available CPU threads.
	# type:uint64
	# work_threads = 8

[node.active_elections]

	# Maximum number of confirmed elections kept in cache to prevent restarting an election. 
	# type:uint64
	# confirmation_cache = 65536

	# Maximum confirmation history size. If tracking the rate of block confirmations, the websocket feature is recommended instead. 
	# type:uint64
	# confirmation_history_size = 2048

	# Limit of hinted elections as percentage of `active_elections_size` 
	# type:uint64
	# hinted_limit_percentage = 20

	# Limit of optimistic elections as percentage of `active_elections_size`. 
	# type:uint64
	# optimistic_limit_percentage = 10

	# Number of active elections. Elections beyond this limit have limited survival time.
	# Warning: modifying this value may result in a lower confirmation rate. 
	# type:uint64,[250..]
	# size = 5000

[node.block_processor]

	# Maximum number of blocks to queue from network peers. 
	# type:uint64
	# max_peer_queue = 128

	# Maximum number of blocks to queue from system components (local RPC, bootstrap). 
	# type:uint64
	# max_system_queue = 16384

	# Priority for bootstrap blocks. Higher priority gets processed more frequently. 
	# type:uint64
	# priority_bootstrap = 8

	# Priority for live network blocks. Higher priority gets processed more frequently. 
	# type:uint64
	# priority_live = 1

	# Priority for local RPC blocks. Higher priority gets processed more frequently. 
	# type:uint64
	# priority_local = 16

[node.bootstrap_ascending]

	# Ascending bootstrap will wait while block processor has more than this many blocks queued.
	# type:uint64
	# block_wait_count = 1000

	# Request limit for accounts from database after which requests will be dropped.
	# Note: changing to unlimited (0) is not recommended as this operation competes for resources on querying the database.
	# type:uint64
	# database_requests_limit = 1024

	# Number of requested blocks for ascending bootstrap request.
	# type:uint64
	# pull_count = 128

	# Request limit to ascending bootstrap after which requests will be dropped.
	# Note: changing to unlimited (0) is not recommended.
	# type:uint64
	# requests_limit = 64

	# Scales the number of samples to track for bootstrap throttling.
	# type:uint64
	# throttle_coefficient = 16

	# Length of time to wait between requests when throttled.
	# type:milliseconds
	# throttle_wait = 100

	# Timeout in milliseconds for incoming ascending bootstrap messages to be processed.
	# type:milliseconds
	# timeout = 3000

[node.bootstrap_ascending.account_sets]

	# Cutoff size limit for the blocked accounts from the priority list.
	# type:uint64
	# blocking_max = 262144

	# Limit the number of account candidates to consider and also the number of iterations.
	# type:uint64
	# consideration_count = 4

	# Waiting time for an account to become available.
	# type:milliseconds
	# cooldown = 3000

	# Cutoff size limit for the priority list.
	# type:uint64
	# priorities_max = 262144

[node.bootstrap_server]

	# Maximum number of requests to process in a single batch. 
	# type:uint64
	# batch_size = 64

	# Maximum number of queued requests per peer. 
	# type:uint64
	# max_queue = 16

	# Number of threads to process requests. 
	# type:uint64
	# threads = 1

[node.diagnostics.txn_tracking]

	# Enable or disable database transaction tracing.
	# type:bool
	# enable = false

	# Ignore any block processor writes less than block_processor_batch_max_time.
	# type:bool
	# ignore_writes_below_block_processor_max_time = true

	# Log stacktrace when read transactions are held longer than this duration.
	# type:milliseconds
	# min_read_txn_time = 5000

	# Log stacktrace when write transactions are held longer than this duration.
	# type:milliseconds
	# min_write_txn_time = 500

[node.experimental]

	# Time limit for blocks age after pruning.
	# type:seconds
	# max_pruning_age = 300

	# Limit for full blocks in chain after pruning.
	# type:uint64
	# max_pruning_depth = 0

	# A list of "address:port" entries to identify work peers for secondary work generation.
	# secondary_work_peers = ["127.0.0.1:8076"]

[node.httpcallback]

	# Callback address.
	# type:string,ip
	# address = ""

	# Callback port number.
	# type:uint16
	# port = 0

	# Callback target path.
	# type:string,uri
	# target = ""

[node.ipc.flatbuffers]

	# Allow client to send unknown fields in json messages. These will be ignored.
	# type:bool
	# skip_unexpected_fields_in_json = true

	# Verify that the buffer is valid before parsing. This is recommended when receiving data from untrusted sources.
	# type:bool
	# verify_buffers = true

[node.ipc.local]

	# If enabled, certain unsafe RPCs can be used. Not recommended for production systems.
	# type:bool
	# allow_unsafe = false

	# Enable or disable IPC via local domain socket.
	# type:bool
	# enable = false

	# Timeout for requests.
	# type:seconds
	# io_timeout = 15

	# Path to the local domain socket.
	# type:string
	# path = "/tmp/nano"

[node.ipc.tcp]

	# Enable or disable IPC via TCP server.
	# type:bool
	# enable = false

	# Timeout for requests.
	# type:seconds
	# io_timeout = 15

	# Server listening port.
	# type:uint16
	# port = 56000

[node.lmdb]

	# Maximum ledger database map size in bytes.
	# type:uint64
	# map_size = 274877906944

	# Maximum open lmdb databases. Increase default if more than 100 wallets is required.
	# Note: external management is recommended when a large amounts of wallets are required (see https://docs.nano.org/integration-guides/key-management/).
	# type:uin32
	# max_databases = 128

	# Sync strategy for flushing commits to the ledger database. This does not affect the wallet database.
	# type:string,{always, nosync_safe, nosync_unsafe, nosync_unsafe_large_memory}
	# sync = "always"

[node.message_processor]

	# Maximum number of messages per peer to queue for processing. 
	# type:uint64
	# max_queue = 64

	# Number of threads to use for message processing. 
	# type:uint64
	# threads = 2

[node.monitor]

	# Enable or disable periodic node status logging
	# type:bool
	# enable = true

	# Interval between status logs
	# type:seconds
	# interval = 60

[node.optimistic_scheduler]

	# Enable or disable optimistic elections
	# type:bool
	# enable = true

	# Minimum difference between confirmation frontier and account frontier to become a candidate for optimistic confirmation
	# type:uint64
	# gap_threshold = 32

	# Maximum number of candidates stored in memory
	# type:uint64
	# max_size = 65536

[node.priority_bucket]

	# Maximum number of blocks to sort by priority per bucket. 
	# Type: uint64
	# max_blocks = 8192

	# Maximum number of slots per bucket available for election activation if the active election count is below the configured limit. 
	# Type: uint64
	# max_elections = 150

	# Number of guaranteed slots per bucket available for election activation. 
	# Type: uint64
	# reserved_elections = 100

[node.rep_crawler]

	# 
	# query_timeout = 60000

[node.request_aggregator]

	# Number of requests to process in a single batch. 
	# type:uint64
	# batch_size = 16

	# Maximum number of queued requests per peer. 
	# type:uint64
	# max_queue = 128

	# Number of threads for request processing. 
	# type:uint64
	# threads = 4

[node.statistics]

	# Maximum number ofmany samples to keep in the ring buffer.
	# type:uint64
	# max_samples = 16384

[node.statistics.log]

	# Log file name for counters.
	# type:string
	# filename_counters = "counters.stat"

	# Log file name for samples.
	# type:string
	# filename_samples = "samples.stat"

	# If true, write headers on each counter or samples writeout.
	# The header contains log type and the current wall time.
	# type:bool
	# headers = true

	# How often to log counters. 0 disables logging.
	# type:milliseconds
	# interval_counters = 0

	# How often to log samples. 0 disables logging.
	# type:milliseconds
	# interval_samples = 0

	# Maximum number of log outputs before rotating the file.
	# type:uint64
	# rotation_count = 100

[node.vote_cache]

	# Maximum age of votes to keep in cache. 
	# type:seconds
	# age_cutoff = 0

	# Maximum number of blocks to cache votes for. 
	# type:uint64
	# max_size = 65536

	# Maximum number of voters to cache per block. 
	# type:uint64
	# max_voters = 64

[node.vote_processor]

	# Maximum number of votes to process in a single batch. 
	# type:uint64
	# batch_size = 1024

	# Maximum number of votes to queue from non-principal representatives. 
	# type:uint64
	# max_non_pr_queue = 32

	# Maximum number of votes to queue from principal representatives. 
	# type:uint64
	# max_pr_queue = 256

	# Priority for votes from principal representatives. Higher priority gets processed more frequently. Non-principal representatives have a baseline priority of 1. 
	# type:uint64
	# pr_priority = 3

	# Number of threads to use for processing votes. 
	# type:uint64
	# threads = 4

[node.websocket]

	# WebSocket server bind address.
	# type:string,ip
	# address = "::1"

	# Enable or disable WebSocket server.
	# type:bool
	# enable = false

	# WebSocket server listening port.
	# type:uint16
	# port = 57000

[opencl]

	# OpenCL device identifier
	# device = 0

	# Enable or disable OpenCL work generation
	# If enabled, consider freeing up CPU resources by setting [work_threads] to zero
	# type:bool
	# enable = false

	# OpenCL platform identifier
	# platform = 0

	# OpenCL thread count
	# threads = 1048576

[rpc]

	# Enable or disable RPC
	# type:bool
	# enable = false

	# Allow or disallow signing of hashes.
	# type:bool
	# enable_sign_hash = false

[rpc.child_process]

	# Enable or disable RPC child process. If false, an in-process RPC server is used.
	# type:bool
	# enable = false

	# Path to the nano_rpc executable. Must be set if child process is enabled.
	# type:string,path
	# rpc_path = "/Users/ruimorais/rsnano/nano/nano_node/../../nano_rpc"

